/******************************************************************/
/*!
\file      OctreeGrid.cpp
\author    Yeo See Kiat Raymond, seekiatraymond.yeo, 2301268
\par       seekiatraymond.yeo@digipen.edu
\date      October 3, 2025
\brief     This file contains the grid generated by the Octree system,
			holding the graph to be accessed and determines how the
			octree should be created.


Copyright (C) 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents without the
prior written consent of DigiPen Institute of Technology is prohibited.
*/
/********************************************************************/

#include "OctreeGrid.h"

namespace Octrees {
	Octree::Octree() {

	}

	Octree::Octree(float minNodeSize, Graph _graph) {
		graph = _graph;

		CalculateBounds();
		CreateTree(minNodeSize);

		GetEmptyLeaves(&root);
		GetEdges();
	}

	void Octree::GetEmptyLeaves(OctreeNode* node) {

		if (node->IsLeaf() && !node->objects.size()) {
			emptyLeaves.push_back(*node);
			graph.AddNode(*node);
			return;
		}

		if (node->children.empty()) {
			// THIS MIGHT BE CAUSING ERRORS, IDK
			//std::cout << "CHILD IS EMPTY\n";
			return;
		}

		for (OctreeNode& child : node->children) {
			//std::cout << "CALLING CHILD: " << child.bounds.center.x << ", " << child.bounds.center.y << ", " << child.bounds.center.z << std::endl;
			GetEmptyLeaves(&child);
		}

		for (int i = 0; i < node->children.size(); ++i) {
			for (int j = i + 1; j < node->children.size(); ++j) {
				if (i == j)
					continue;

				//std::cout << "ADDING EDGE: " << node->children[i].bounds.center.x << ", " << node->children[i].bounds.center.y << ", " << node->children[i].bounds.center.z << " | " <<
				//	node->children[j].bounds.center.x << ", " << node->children[j].bounds.center.y << ", " << node->children[j].bounds.center.z << std::endl;
				graph.AddEdge(&node->children[i], &node->children[j]);
			}
		}

		std::cout << "\n";
	}

	void Octree::CreateTree(float minNodeSize) {
		ecs::ECS* ecs = ecs::ECS::GetInstance();
		root = OctreeNode(bounds, minNodeSize);
		for (const auto& id : ecs->GetEntitySignatureData()) {
			ecs::BoxColliderComponent* boxCollider = ecs->GetComponent<ecs::BoxColliderComponent>(id.first);

			if (!boxCollider)
				continue;

			root.Divide(id.first);
		}
	}

	void Octree::CalculateBounds() {
		ecs::ECS* ecs = ecs::ECS::GetInstance();
		glm::vec3 minBound(std::numeric_limits<float>::max(), std::numeric_limits<float>::max(), std::numeric_limits<float>::max()),
			maxBound(std::numeric_limits<float>::lowest(), std::numeric_limits<float>::lowest(), std::numeric_limits<float>::lowest());

		glm::vec3 boundCenter(0.f, 0.f, 0.f);

		for (const auto& id : ecs->GetEntitySignatureData()) {
			ecs::BoxColliderComponent* boxCollider = ecs->GetComponent<ecs::BoxColliderComponent>(id.first);
			ecs::TransformComponent* transform = ecs->GetComponent<ecs::TransformComponent>(id.first);

			if (!boxCollider)
				continue;

			if (boxCollider->box.bounds.min.x + transform->WorldTransformation.position.x < minBound.x) {
				minBound.x = boxCollider->box.bounds.min.x + transform->WorldTransformation.position.x;
			}
			if (boxCollider->box.bounds.min.y + transform->WorldTransformation.position.y < minBound.y) {
				minBound.y = boxCollider->box.bounds.min.y + transform->WorldTransformation.position.y;
			}
			if (boxCollider->box.bounds.min.z + transform->WorldTransformation.position.z < minBound.z) {
				minBound.z = boxCollider->box.bounds.min.z + transform->WorldTransformation.position.z;
			}
			if (boxCollider->box.bounds.max.x + transform->WorldTransformation.position.x > maxBound.x) {
				maxBound.x = boxCollider->box.bounds.max.x + transform->WorldTransformation.position.x;
			}
			if (boxCollider->box.bounds.max.y + transform->WorldTransformation.position.y > maxBound.y) {
				maxBound.y = boxCollider->box.bounds.max.y + transform->WorldTransformation.position.y;
			}
			if (boxCollider->box.bounds.max.z + transform->WorldTransformation.position.z > maxBound.z) {
				maxBound.z = boxCollider->box.bounds.max.z + transform->WorldTransformation.position.z;
			}
		}

		boundCenter.x = (minBound.x + maxBound.x) / 2.f;
		boundCenter.y = (minBound.y + maxBound.y) / 2.f;
		boundCenter.z = (minBound.z + maxBound.z) / 2.f;
		glm::vec3 boundSize = glm::vec3(1.f, 1.f, 1.f) * std::max(std::max(maxBound.x - minBound.x, maxBound.y - minBound.y), maxBound.z - minBound.z) * 0.6f;
		glm::vec3 boundMin = boundCenter - boundSize, boundMax = boundCenter + boundSize;

		bounds.center = boundCenter;
		bounds.size = boundSize;
		//bounds.SetMinMax(boundMin, boundMax);
	}

	void Octree::GetEdges() {
		//std::cout << "EMPTY LEAVES COUNT: " << emptyLeaves.size();

		for (OctreeNode leaf : emptyLeaves) {
			//std::cout << "EMPTY LEAF CENTER: " << leaf.bounds.center.x << ", " << leaf.bounds.center.y << ", " << leaf.bounds.center.z << std::endl;
			//std::cout << "EMPTY LEAF SIZE: " << leaf.bounds.size.x << "," << leaf.bounds.size.y << ", " << leaf.bounds.size.z << std::endl << std::endl;
			for (OctreeNode otherLeaf : emptyLeaves) {
				if (leaf == otherLeaf)
					continue;

				//if (leaf.bounds.Intersects(otherLeaf.bounds)) {
				//	//std::cout << leaf.bounds.center.x <<  ", " << leaf.bounds.center.y << ", " << leaf.bounds.center.z << " INTERSECTING WITH "
				//	//	<< otherLeaf.bounds.center.x << ", " << otherLeaf.bounds.center.y << ", " << otherLeaf.bounds.center.z << std::endl;
				//	graph.AddEdge(&leaf, &otherLeaf);
				//}

				Bounds otherBounds = otherLeaf.bounds;
				otherBounds.size *= 1.1f;
					if (leaf.bounds.Intersects(otherBounds)) {
					//std::cout << leaf.bounds.center.x <<  ", " << leaf.bounds.center.y << ", " << leaf.bounds.center.z << " INTERSECTING WITH "
					//	<< otherLeaf.bounds.center.x << ", " << otherLeaf.bounds.center.y << ", " << otherLeaf.bounds.center.z << std::endl;
					graph.AddEdge(&leaf, &otherLeaf);
				}
			}
		}
	}

	//OctreeNode Octree::FindClosestNode(glm::vec3 position) {
	//	FindClosestNode(root, position);
	//}

	//OctreeNode Octree::FindClosestNode(OctreeNode node, glm::vec3 position) {
	//	Octree found;

	//	for (int i = 0; i < node.children.size(); ++i) {
	//		if(node.children[i].bounds)
	//	}
	//}

	OctreeNode Octree::GetClosestNode(glm::vec3 position) {
		OctreeNode closestNode;

		float closestDistanceSqr = std::numeric_limits<float>().max();

		for (Node node : graph.nodes) {
			OctreeNode octreeNode = node.octreeNode;
			float distanceSqr = glm::length2(octreeNode.bounds.center - position);

			if (distanceSqr < closestDistanceSqr) {
				closestDistanceSqr = distanceSqr;
				closestNode = octreeNode;
			}
		}

		return closestNode;
	}
}